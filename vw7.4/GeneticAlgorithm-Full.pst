<?xml version="1.0"?><st-source><!-- Name: GeneticAlgorithm-FullBundleName: GeneticAlgorithm-FullBundleStructure: a Store.BundleForParcelParcel: #('GeneticAlgorithm-Full')ParcelName: GeneticAlgorithm-FullDate: 12:18:20 am April 26, 2021 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on April 26, 2021 at 12:18:20 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GeneticAlgorithm</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>GeneticAlgorithm</category><attributes><package>GeneticAlgorithm</package></attributes></name-space><class><name>GALog</name><environment>GeneticAlgorithm</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generationNumber timeToProduceGeneration fittestIndividual worseFitness averageFitness time </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAIndividualTest</name><environment>GeneticAlgorithm</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Tests</category><attributes><package>GeneticAlgorithm-Tests</package></attributes></class><comment><class-id>GeneticAlgorithm.GAIndividualTest</class-id><body>This class contains tests</body></comment><class><name>GAObject</name><environment>GeneticAlgorithm</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAEngine</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitnessBlock createGeneBlock numberOfGenes populationSize logs population terminationBlock compareFitness mutationOperator crossoverOperator selection beforeCreatingInitialIndividual </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAEngineTest</name><environment>GeneticAlgorithm</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Tests</category><attributes><package>GeneticAlgorithm-Tests</package></attributes></class><comment><class-id>GeneticAlgorithm.GAEngineTest</class-id><body>This class contains tests</body></comment><class><name>GAOrderedCrossoverOperationTest</name><environment>GeneticAlgorithm</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>i1 i2 op </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Tests</category><attributes><package>GeneticAlgorithm-Tests</package></attributes></class><comment><class-id>GeneticAlgorithm.GAOrderedCrossoverOperationTest</class-id><body>This class contains tests</body></comment><class><name>GAOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAAbstractMutationOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GASwapMutationOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAAbstractMutationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>UIManager</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>percent fork </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>GeneticAlgorithm-Extensions</category><attributes><package>GeneticAlgorithm-Extensions</package></attributes></class><class><name>GAMutationOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAAbstractMutationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>geneFactoryBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GACrossoverOperationTest</name><environment>GeneticAlgorithm</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>i1 i2 op </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Tests</category><attributes><package>GeneticAlgorithm-Tests</package></attributes></class><comment><class-id>GeneticAlgorithm.GACrossoverOperationTest</class-id><body>This class contains tests</body></comment><class><name>GAIndividual</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>genes fitness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAExamples</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			GeneticAlgorithm.*			</imports><category>GeneticAlgorithm-Extensions</category><attributes><package>GeneticAlgorithm-Extensions</package></attributes></class><class><name>GAMutationOperationTest</name><environment>GeneticAlgorithm</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>i op </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Tests</category><attributes><package>GeneticAlgorithm-Tests</package></attributes></class><comment><class-id>GeneticAlgorithm.GAMutationOperationTest</class-id><body>This class contains tests</body></comment><class><name>GAAbstractCrossoverOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GACrossoverOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAAbstractCrossoverOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAConstrainedCrossoverOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAAbstractCrossoverOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>possibleCutpoints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GAOrderedCrossoverOperation</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GAAbstractCrossoverOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GASelection</name><environment>GeneticAlgorithm</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>population fittest initialPopulation fitnessBlock populationSize compareFitness engine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><class><name>GATournamentSelection</name><environment>GeneticAlgorithm</environment><super>GeneticAlgorithm.GASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tournamentSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GeneticAlgorithm-Core</category><attributes><package>GeneticAlgorithm-Core</package></attributes></class><methods><class-id>GeneticAlgorithm.GALog</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="averageFitness">averageFitness	"Return the average fitness value of a generation I am representing"	^ averageFitness</body><body package="GeneticAlgorithm-Core" selector="averageFitness:">averageFitness: aNumber	"Set the average fitness value of a generation I am representing"	averageFitness := aNumber</body><body package="GeneticAlgorithm-Core" selector="bestFitness">bestFitness	"Return the best fitness value of a generation I am representing"	^ fittestIndividual fitness</body><body package="GeneticAlgorithm-Core" selector="fittestIndividual">fittestIndividual	"Return the best individual of the generation I represent"	^ fittestIndividual</body><body package="GeneticAlgorithm-Core" selector="fittestIndividual:">fittestIndividual: anIndividual	"Set the best individual of the generation I represent"	fittestIndividual := anIndividual</body><body package="GeneticAlgorithm-Core" selector="generationNumber">generationNumber	"Return the generation number I represent"	^ generationNumber</body><body package="GeneticAlgorithm-Core" selector="generationNumber:">generationNumber: generationNumberAsInteger	"Set the generation number I am representing"	generationNumber := generationNumberAsInteger</body><body package="GeneticAlgorithm-Core" selector="initialize">initialize	super initialize.	time := Timestamp now</body><body package="GeneticAlgorithm-Core" selector="printOn:">printOn: str	"Printing the log object"	super printOn: str.	str nextPut: $&lt;.	str nextPutAll: fittestIndividual genes asString.	str nextPut: $&gt;</body><body package="GeneticAlgorithm-Core" selector="time">time	"Return the time the log was created"	^ time</body><body package="GeneticAlgorithm-Core" selector="timeToProduceGeneration">timeToProduceGeneration	"Time to produce the generation I represent"	^ timeToProduceGeneration</body><body package="GeneticAlgorithm-Core" selector="timeToProduceGeneration:">timeToProduceGeneration: anInteger	"Set the time to produce the generation I am representing"	timeToProduceGeneration := anInteger</body><body package="GeneticAlgorithm-Core" selector="worseFitness">worseFitness	"Return the worse fitness value of a generation I am representing"	^ worseFitness</body><body package="GeneticAlgorithm-Core" selector="worseFitness:">worseFitness: aNumber	"Set the worst fitness value of a generation I am representing"	worseFitness := aNumber</body></methods><methods><class-id>GeneticAlgorithm.GALog class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Core" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAIndividualTest</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Tests" selector="testCreationWithCharacters">testCreationWithCharacters	| r individuals f ind |	r := Random seed: 42.	f := [ :random | ($a to: $z) atRandom: random ].	individuals := GAIndividual		create: 100		individualsAndInitialize: 10		genesWith: f		using: r.	self assert: individuals size equals: 100.	self		assert: (individuals collect: #numberOfGenes) asSet asArray		equals: #(10).	ind := individuals anyOne.	self assert: (ind genes allSatisfy: [ :c | ($a to: $z) includes: c ])</body></methods><methods><class-id>GeneticAlgorithm.GAIndividualTest class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Tests" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAObject</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="checkForRandomNumber">checkForRandomNumber	self		assert: [ random notNil ]		description: 'Need to provide a random number generator'</body><body package="GeneticAlgorithm-Core" selector="random">random	"Return the random number generator associated to the object"	^ random</body><body package="GeneticAlgorithm-Core" selector="random:">random: aRandomNumberGenerator	"Set the random number generator associated to the object. The argument must be an instance of Random."	random := aRandomNumberGenerator</body><body package="GeneticAlgorithm-Core" selector="randomNumber">randomNumber	"Return a number between 0.0 and 1.0"	^ random next</body></methods><methods><class-id>GeneticAlgorithm.GAObject class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Core" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAEngine</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="beforeCreatingInitialIndividual:">beforeCreatingInitialIndividual: aOneArgBlock	"Set the behavior to be executed before creating an individual.	The block takes a random number generator as argument."	beforeCreatingInitialIndividual := aOneArgBlock</body><body package="GeneticAlgorithm-Core" selector="beforeRun">beforeRun	"Method executed before creating the initial population"	self checkIfReadyToRun.	selection fitnessBlock: fitnessBlock.	selection populationSize: populationSize</body><body package="GeneticAlgorithm-Core" selector="checkIfReadyToRun">checkIfReadyToRun	"Raise an exception if the configuration is not ready to be run"	self		assert: [ fitnessBlock notNil ]		description: 'Need to set a fitnessBlock'.	self		assert: [ createGeneBlock notNil ]		description: 'Need to set a createGeneBlock'.	self		assert: [ numberOfGenes notNil ]		description: 'Need to set how many genes you wish to have, using numberOfGenes:'.	self assert: [ logs isEmpty ] description: 'Already been run'</body><body package="GeneticAlgorithm-Core" selector="createGeneBlock:">createGeneBlock: threeArgBlock	"Three arguments must be provided rand, index, and the individual being filled"	createGeneBlock := threeArgBlock.	mutationOperator geneFactoryBlock: threeArgBlock</body><body package="GeneticAlgorithm-Core" selector="crossover:with:">crossover: partnerA with: partnerB	"Perform a crossover operation between the two arguments"	^ crossoverOperator crossover: partnerA with: partnerB</body><body package="GeneticAlgorithm-Core" selector="crossoverOperator:">crossoverOperator: aCrossoverOperator	"Set the crossover operator used in the algorithm"	crossoverOperator := aCrossoverOperator.	crossoverOperator random: random</body><body package="GeneticAlgorithm-Core" selector="endForMaxNumberOfGeneration:">endForMaxNumberOfGeneration: nbOfGenerations	"End the algorithm after a fixed number of generations"	terminationBlock := [ logs last generationNumber &gt;= nbOfGenerations ]</body><body package="GeneticAlgorithm-Core" selector="endIfFitnessIsAbove:">endIfFitnessIsAbove: aFitnessValueThreshold	"End the algorithm if the best fitness value is above a particular threshold"	terminationBlock := [ logs last fittestIndividual fitness		&gt;= aFitnessValueThreshold ]</body><body package="GeneticAlgorithm-Core" selector="endIfNoImprovementFor:">endIfNoImprovementFor: nbOfGenerations	"End if no improvement occurred within a given number of generations"	^ self endIfNoImprovementFor: nbOfGenerations withinRangeOf: 0</body><body package="GeneticAlgorithm-Core" selector="endIfNoImprovementFor:withinRangeOf:">endIfNoImprovementFor: nbOfGenerations withinRangeOf: delta	"End if no improvement occurred (within a delta value) within a given number of generations"	terminationBlock := [ logs last generationNumber &gt;= nbOfGenerations		and: [ | fs |			fs := (logs last: nbOfGenerations)				collect: [ :aLog | aLog fittestIndividual fitness ].			fs max - fs min &lt;= delta ] ]</body><body package="GeneticAlgorithm-Core" selector="fitnessBlock">fitnessBlock	"Return the fitness block used by the engine"	^ fitnessBlock</body><body package="GeneticAlgorithm-Core" selector="fitnessBlock:">fitnessBlock: aOneArgBlock	"The argument is evaluated on the genes of each individual.	The block argument has to compute the fitness."	fitnessBlock := aOneArgBlock</body><body package="GeneticAlgorithm-Core" selector="initialize">initialize	super initialize.	logs := OrderedCollection new.	random := Random seed: 42.	self endForMaxNumberOfGeneration: 10.	populationSize := 10.	self maximizeComparator.	mutationOperator := GAMutationOperation new.	mutationOperator mutationRate: 0.01.	mutationOperator random: random.	crossoverOperator := GACrossoverOperation new.	crossoverOperator random: random.	self selection: GATournamentSelection new.	beforeCreatingInitialIndividual := [ :rand | "do nothing per default" ]</body><body package="GeneticAlgorithm-Core" selector="initializePopulation">initializePopulation	self checkForRandomNumber.	population := OrderedCollection new.	populationSize		timesRepeat: [ | ind |			beforeCreatingInitialIndividual value: random.			ind := GAIndividual new.			population				add:					(ind						random: random;						set: numberOfGenes genesUsing: createGeneBlock) ]</body><body package="GeneticAlgorithm-Core" selector="isIndividual:betterThan:">isIndividual: anIndividual betterThan: aFittestIndividual	"Compare an individual against the fittest individual of the population"	^ compareFitness		value: anIndividual fitness		value: aFittestIndividual fitness</body><body package="GeneticAlgorithm-Core" selector="logs">logs	"Return the logs of the run"	^ logs</body><body package="GeneticAlgorithm-Core" selector="maximizeComparator">maximizeComparator	"A better individual is the one with the highest fitness value"	compareFitness := [ :f1 :f2 | f1 &gt; f2 ]</body><body package="GeneticAlgorithm-Core" selector="microPause">microPause	"Useful when you wish to log in the Transcript and see progresses"	(Delay forMilliseconds: 1) wait.</body><body package="GeneticAlgorithm-Core" selector="minimizeComparator">minimizeComparator	"A better individual is the one with the lowest fitness value"	compareFitness := [ :f1 :f2 | f1 &lt; f2 ]</body><body package="GeneticAlgorithm-Core" selector="mutate:">mutate: individual	"Mutate the child provided as argument"	^ mutationOperator mutate: individual</body><body package="GeneticAlgorithm-Core" selector="mutationOperator:">mutationOperator: aMutationOperator	mutationOperator := aMutationOperator.	aMutationOperator random: random</body><body package="GeneticAlgorithm-Core" selector="mutationRate:">mutationRate: aFloat	"Set the mutation rate used by the engine. The default value is 0.01"	mutationOperator mutationRate: aFloat</body><body package="GeneticAlgorithm-Core" selector="numberOfGenes:">numberOfGenes: anInteger	"Set the number of genes each individual will have"	numberOfGenes := anInteger</body><body package="GeneticAlgorithm-Core" selector="populationSize:">populationSize: anInteger	"Set the population size"	populationSize := anInteger</body><body package="GeneticAlgorithm-Core" selector="produceNewPopulation">produceNewPopulation	"This method  		- produces a new population, set in the variable 'population'		- select the fittest element of the population"	selection doSelection.	population := selection population</body><body package="GeneticAlgorithm-Core" selector="randomNumber:">randomNumber: maxNumber	"Return a number between 1 and maxNumber"	^ random nextInt: maxNumber</body><body package="GeneticAlgorithm-Core" selector="result">result	"Return the genes of the fittest individual. This method is expected to be executed after #run has completed"	^ self logs last fittestIndividual genes</body><body package="GeneticAlgorithm-Core" selector="run">run	"Public method -- Run the genetic algorithm"	| t log |	self beforeRun.	self initializePopulation.	selection initialPopulation: population.	selection compareFitness: compareFitness.	UIManager default		informUserDuring: [ :bar | 			| gen |			gen := 0.			[ self shouldTerminate ]				whileFalse: [ gen := gen + 1.					bar label: gen asString.					self microPause.					t := Time now asSeconds.					self produceNewPopulation.					log := GALog new.					log generationNumber: gen.					log fittestIndividual: selection fittest.					log						worseFitness:							((population collect: #fitness)								inject: log bestFitness								into: [ :wFit :current | 									(compareFitness value: wFit value: current)										ifTrue: [ current ]										ifFalse: [ wFit ] ]).					log						averageFitness: (population collect: #fitness) average asFloat.					log timeToProduceGeneration: Time now asSeconds - t.					logs add: log ] ]</body><body package="GeneticAlgorithm-Core" selector="selection">selection	"Return the selection operator"	^ selection</body><body package="GeneticAlgorithm-Core" selector="selection:">selection: aSelection	"Set the selection method to be used to create a new population"	selection := aSelection.	aSelection engine: self</body><body package="GeneticAlgorithm-Core" selector="shouldTerminate">shouldTerminate	logs ifEmpty: [ ^ false ].	^ terminationBlock value</body><body package="GeneticAlgorithm-Core" selector="timeTaken">timeTaken	"Return the time taken to compute all the generations"	| lastLog |	lastLog := self logs last.	^ lastLog time - self logs first time</body><body package="GeneticAlgorithm-Core" selector="visualize">visualize	"Visualize the evolution of the population"	| g d |	g := RTGrapher new.	d := RTData new.	d label: 'Best fitness'.	d interaction popupText: [ :assoc | assoc value bestFitness ].	d connectColor: Color blue.	d noDot.	d points: self logs.	d y: #bestFitness.	d x: #generationNumber.	g add: d.	d := RTData new.	d label: 'Worst fitness'.	d interaction popupText: [ :assoc | assoc value worseFitness ].	d connectColor: Color red.	d noDot.	d points: self logs.	d y: #worseFitness.	d x: #generationNumber.	g add: d.	d := RTData new.	d label: 'Average fitness'.	d interaction popupText: [ :assoc | assoc value averageFitness ].	d connectColor: Color green.	d noDot.	d points: self logs.	d y: #averageFitness.	d x: #generationNumber.	g add: d.	g legend addText: 'Fitness evolution'.	g axisY title: 'Fitness'.	g axisX		noDecimal;		title: 'Generation'.	^ g</body></methods><methods><class-id>GeneticAlgorithm.GAEngineTest</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Tests" selector="testExamples01">testExamples01	| g |	g := GAEngine new.	g populationSize: 1000.	g numberOfGenes: 4.	g createGeneBlock: [ :rand :index :ind | ($a to: $z) atRandom: rand ].	g		fitnessBlock: [ :genes | 			(#($g $a $t $o)				with: genes				collect: [ :a :b | 					a = b						ifTrue: [ 1 ]						ifFalse: [ 0 ] ]) sum ].	g run.	self assert: g logs first fittestIndividual fitness equals: 2.	self		assert: g logs first fittestIndividual genes		equals: #($g $l $t $s).	self assert: g logs fourth fittestIndividual fitness equals: 4.	self		assert: g logs fourth fittestIndividual genes		equals: #($g $a $t $o)</body></methods><methods><class-id>GeneticAlgorithm.GAEngineTest class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Tests" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAOrderedCrossoverOperationTest</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Tests" selector="setUp">setUp	super setUp.	i1 := GAIndividual new genes: #(8 4 7 3 6 2 5 1 9 0).	i2 := GAIndividual new genes: #(0 1 2 3 4 5 6 7 8 9).	op := GAOrderedCrossoverOperation new</body><body package="GeneticAlgorithm-Tests" selector="testCrossover1">testCrossover1	| i3 |	i3 := op		crossover: i1		with: i2		from: 4		to: 8.	self assert: i3 genes equals: #(0 4 7 3 6 2 5 1 8 9)</body><body package="GeneticAlgorithm-Tests" selector="testCrossover2">testCrossover2	| i3 |	i3 := op		crossover: i1		with: i2		from: 1		to: 4.	self assert: i3 genes equals: #(8 4 7 3 0 1 2 5 6 9)</body><body package="GeneticAlgorithm-Tests" selector="testCrossover3">testCrossover3	| i3 |	i3 := op		crossover: i1		with: i2		from: 9		to: 10.	self assert: i3 genes equals: #(1 2 3 4 5 6 7 8 9 0)</body><body package="GeneticAlgorithm-Tests" selector="testCrossover4">testCrossover4	| i3 |	i1 := GAIndividual new genes: #(1 2 3 4 5 6 7 8 9).	i2 := GAIndividual new genes: #(9 8 7 6 5 4 3 2 1).	i3 := op		crossover: i1		with: i2		from: 6		to: 8.	self assert: i3 genes equals: #(9 5 4 3 2 6 7 8 1)</body></methods><methods><class-id>GeneticAlgorithm.GAOrderedCrossoverOperationTest class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Tests" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAAbstractMutationOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="doMutate:">doMutate: individual	"To be overridden"	self subclassResponsibility</body><body package="GeneticAlgorithm-Core" selector="geneFactoryBlock:">geneFactoryBlock: oneArgBlock	"Do nothing. May be overridden if necessary"	</body><body package="GeneticAlgorithm-Core" selector="initialize">initialize	super initialize.	self mutationRate: 0.01</body><body package="GeneticAlgorithm-Core" selector="mutate:">mutate: individual	"Return a new individual (different object than the argument), result of a mutation from the individual provided as argument."	| newIndividual |	newIndividual := GAIndividual new.	newIndividual random: random.	newIndividual genes: individual genes copy.	self doMutate: newIndividual.	^ newIndividual</body><body package="GeneticAlgorithm-Core" selector="mutationRate">mutationRate	"Return the used mutation rate. Typically, a small positive number, close to 0.0 and significantly less than 1.0"	^ mutationRate</body><body package="GeneticAlgorithm-Core" selector="mutationRate:">mutationRate: aFloat	"Set the mutation rate. Typically, a small positive number, close to 0.0 and significantly less than 1.0"	mutationRate := aFloat</body></methods><methods><class-id>GeneticAlgorithm.GASwapMutationOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="doMutate:">doMutate: individual	"Mutate genes of the argument by swapping two gene values"	| i2 tmp |	self checkForRandomNumber.	1 to: individual genes size do: [ :i1 | 		self randomNumber &lt;= mutationRate			ifTrue: [ i2 := random nextInt: individual genes size.				tmp := individual genes at: i1.				individual genes at: i1 put: (individual genes at: i2).				individual genes at: i2 put: tmp ] ]</body></methods><methods><class-id>UIManager</class-id> <category>public</category><body package="GeneticAlgorithm-Extensions" selector="informUserDuring:">informUserDuring: aBlock	"	UIManager default informUserDuring: [:bar|		#('one' 'two' 'three') do: [:info|			bar label: info.			1 to: 100 do: [:v |				bar current: v.				(Delay forMilliseconds: 20) wait]]]	"	fork ifNotNil: [ ^ self ].	fork := [		[self open.		aBlock value: self.		self closeRequest.		] ensure: [ fork := nil ].	] fork.	[ fork isNil not ] whileTrue: [ (Delay forMilliseconds: 20) wait ].	"aBlock value: UIManagerBar new."</body></methods><methods><class-id>UIManager</class-id> <category>aspects</category><body package="GeneticAlgorithm-Extensions" selector="current:">current: aNumber	self percent value: aNumber/100.0</body><body package="GeneticAlgorithm-Extensions" selector="label:">label: aString	self mainWindow label: aString</body><body package="GeneticAlgorithm-Extensions" selector="percent">percent	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^percent isNil		ifTrue:			[percent := 0.5 asValue]		ifFalse:			[percent]</body></methods><methods><class-id>UIManager class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Extensions" selector="default">default	^ default ifNil: [default := self new ].</body></methods><methods><class-id>GeneticAlgorithm.GAMutationOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="checkForGeneFactory">checkForGeneFactory	self		assert: [ geneFactoryBlock notNil ]		description: 'Need to provide a block to create gene'</body><body package="GeneticAlgorithm-Core" selector="doMutate:">doMutate: individual	"Mutate genes of the argument"	self checkForRandomNumber.	self checkForGeneFactory.	1 to: individual genes size do: [ :index | 		self randomNumber &lt;= mutationRate			ifTrue: [ individual genes					at: index					put: (geneFactoryBlock cull: random cull: index cull: individual) ] ]</body><body package="GeneticAlgorithm-Core" selector="geneFactoryBlock">geneFactoryBlock	"Return the three-arg block used to create a gene, following the pattern	[ :rand :index :ind | ... ]	rand is the random number generator, 	index is index of the gene,	ind is the individual being filled"	^ geneFactoryBlock</body><body package="GeneticAlgorithm-Core" selector="geneFactoryBlock:">geneFactoryBlock: oneArgBlock	"The block receive a random number as argument"	geneFactoryBlock := oneArgBlock</body></methods><methods><class-id>GeneticAlgorithm.GACrossoverOperationTest</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Tests" selector="setUp">setUp	super setUp.	i1 := GAIndividual new genes: 'abcd'.	i2 := GAIndividual new genes: 'defg'.	op := GACrossoverOperation new</body><body package="GeneticAlgorithm-Tests" selector="testCrossover1">testCrossover1	| i3 |	i3 := op crossover: i1 with: i2 midpoint: 2.	self assert: i3 genes equals: 'abfg'</body><body package="GeneticAlgorithm-Tests" selector="testCrossover2">testCrossover2	| i3 |	i3 := op crossover: i1 with: i2 midpoint: 1.	self assert: i3 genes equals: 'aefg'</body><body package="GeneticAlgorithm-Tests" selector="testCrossover3">testCrossover3	| i3 |	i3 := op crossover: i1 with: i2 midpoint: 0.	self assert: i3 genes equals: 'defg'</body><body package="GeneticAlgorithm-Tests" selector="testCrossover4">testCrossover4	| i3 |	op random: (Random seed: 42).	i3 := op crossover: i1 with: i2.	self assert: i3 genes equals: 'aefg'</body></methods><methods><class-id>GeneticAlgorithm.GACrossoverOperationTest class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Tests" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAIndividual</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="computeFitnessUsing:">computeFitnessUsing: fitnessBlock	"Compute the fitness of myself if not already computed"	self		assert: [ genes notNil ]		description: 'Need to have some genes first'.	"Simply exit if already computed"	fitness ifNotNil: [ ^ self ].	"Compute the fitness score"	fitness := fitnessBlock value: genes</body><body package="GeneticAlgorithm-Core" selector="fitness">fitness	"Return the fitness value of the individual"	^ fitness</body><body package="GeneticAlgorithm-Core" selector="genes">genes	"Return the individual's genes"	^ genes</body><body package="GeneticAlgorithm-Core" selector="genes:">genes: someGenes	"Set the genes of the individual. Used by the genetic operations."	genes := someGenes</body><body package="GeneticAlgorithm-Core" selector="numberOfGenes">numberOfGenes	"Return the number of genes the individual has"	^ self genes size</body><body package="GeneticAlgorithm-Core" selector="set:genesUsing:">set: numberOfGenes genesUsing: geneBlockFactory	"Public method - Generate the genes of the individual"	self checkForRandomNumber.	genes := (1 to: numberOfGenes)		collect: [ :index | geneBlockFactory cull: random cull: index cull: self ]</body></methods><methods><class-id>GeneticAlgorithm.GAIndividual class</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="create:individualsAndInitialize:genesWith:">create: numberOfIndividuals individualsAndInitialize: numberOfGenes genesWith: geneBlockFactory	"Factory method to easily create a number of Individuals.        numberOfIndividuals : is the number of individuals to return        numberOfGenes : number of genes each individual should have        geneBlockFactory : is a one-argument block to generate a gene. It takes a random generator as argument"	^ self		create: numberOfIndividuals		individualsAndInitialize: numberOfGenes		genesWith: geneBlockFactory		using: (Random new seed: 42)</body><body package="GeneticAlgorithm-Core" selector="create:individualsAndInitialize:genesWith:using:">create: numberOfIndividuals individualsAndInitialize: numberOfGenes genesWith: geneBlockFactory using: randomNumberGeneration	"Factory method to easily create a population of Individuals.		numberOfIndividuals : is the number of individuals to return		numberOfGenes : number of genes each individual should have		geneBlockFactory : is a one-argument block to generate a gene. It takes a random generator as argument		randomNumberGeneration : is a random generator"	| someIndividuals ind |	someIndividuals := OrderedCollection new.	numberOfIndividuals		timesRepeat: [ ind := self new.			ind random: randomNumberGeneration.			ind set: numberOfGenes genesUsing: geneBlockFactory.			someIndividuals add: ind ].	^ someIndividuals</body></methods><methods><class-id>GAExamples</class-id> <category>initialize-release</category><body package="GeneticAlgorithm-Extensions" selector="initialize">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>GAExamples</class-id> <category>examples</category><body package="GeneticAlgorithm-Extensions" selector="example01">example01	"	self new example01	"	| numberOfIdentifyFactors primeNumbers candidateFactors g |	numberOfIdentifyFactors := 345.	primeNumbers := #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199).	candidateFactors := #(1), primeNumbers.	g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 10000.	g numberOfGenes: 10.	g createGeneBlock: 		[ :rand :index :ind | candidateFactors atRandom: rand ].	g minimizeComparator.	g		fitnessBlock: [ :genes | 			((genes inject: 1 into: [ :r :v | r * v ]) - numberOfIdentifyFactors) abs ].	g run.	g inspect</body><body package="GeneticAlgorithm-Extensions" selector="example02">example02	"	self new example02	"	| numberOfIdentifyFactors primeNumbers candidateFactors g |	numberOfIdentifyFactors := 345.	primeNumbers := #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199).	candidateFactors := #(1), primeNumbers.	g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 10000.	g numberOfGenes: 10.	g createGeneBlock: 		[ :rand :index :ind | candidateFactors atRandom: rand ].	g minimizeComparator.	g		fitnessBlock: [ :genes | 			((genes inject: 1 into: [ :r :v | r * v ]) - numberOfIdentifyFactors) abs ].	g run.	g inspect	"g logs last bestFitness."</body><body package="GeneticAlgorithm-Extensions" selector="example03">example03	"	self new example03	"	| numberOfIdentifyFactors primeNumbers candidateFactors g |	numberOfIdentifyFactors := 345.	primeNumbers := #(2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191 193 197 199).	candidateFactors := #(1), primeNumbers.	g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 10000.	g numberOfGenes: 10.	g createGeneBlock: 		[ :rand :index :ind | candidateFactors atRandom: rand ].	g minimizeComparator.	g		fitnessBlock: [ :genes | 			((genes inject: 1 into: [ :r :v | r * v ]) - numberOfIdentifyFactors) abs ].	g run.	g inspect.	"g logs last bestFitness.	g result copyWithout: 1."</body><body package="GeneticAlgorithm-Extensions" selector="example04">example04	"	self new example04	"	| knapsackMaxWeight boxes g |	knapsackMaxWeight := 15.	"a box = (value, weight)"	boxes := #(#(4 12) #(2 1) #(2 2) #(1 1) #(10 4) #(0 0)).			g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 20000.	g numberOfGenes: 15.	g createGeneBlock: [ :rand :index :ind | boxes atRandom: rand ].	g maximizeComparator.	g		fitnessBlock: [ :genes | 			| totalWeight totalValue penalty |			totalValue := (genes collect: #first) sum.			totalWeight := (genes collect: #second) sum.			knapsackMaxWeight &lt; totalWeight 				ifTrue: [ penalty := (knapsackMaxWeight - totalWeight) abs * 50 ]				ifFalse: [ penalty := 0 ].			totalValue - penalty			 ].	g run.	(g result copyWithout: #(0 0)) inspect.</body><body package="GeneticAlgorithm-Extensions" selector="example05">example05	"	self new example05	"	| knapsackMaxWeight boxes g decodeToBoxes |	knapsackMaxWeight := 15.	"a box = (value, weight)"	boxes := #(#(4 12) #(2 1) #(2 2) #(1 1) #(10 4) ).			g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 20000.	g numberOfGenes: boxes size.	g createGeneBlock: [ :rand :index :ind | #(0 1) atRandom: rand ].	g maximizeComparator.	g fitnessBlock: [ :genes | 			| totalWeight totalValue penalty |			decodeToBoxes := OrderedCollection new.			genes doWithIndex: [ :b :ind | b = 1 ifTrue: [ decodeToBoxes add: (boxes at: ind) ] ].			decodeToBoxes 				ifEmpty: [ totalValue := 0. totalWeight := 0 ]				ifNotEmpty: [ 					totalValue := (decodeToBoxes collect: #first) sum.					totalWeight := (decodeToBoxes collect: #second) sum ].			knapsackMaxWeight &lt; totalWeight 				ifTrue: [ penalty := (knapsackMaxWeight - totalWeight) abs * 50 ]				ifFalse: [ penalty := 0 ].						totalValue - penalty ].	g run.		"We now retrieve the solution"	decodeToBoxes := OrderedCollection new.	g result doWithIndex: [ :b :ind | 				b = 1 ifTrue: [ decodeToBoxes add: (boxes at: ind) ] ].	decodeToBoxes inspect</body><body package="GeneticAlgorithm-Extensions" selector="example06">example06	"	self new example06	"	"We assume that each meeting is correctly defined"		"a meeting = (start time, end time)"	| meetings numberOfMeetings g numberOfOverlap table |	meetings := #(#(1 3) #(2 3) #(5 6) #(7 9) #(4 7)).	numberOfMeetings := meetings size.			g := GAEngine new.	g endIfNoImprovementFor: 10.	g populationSize: 20000.	g numberOfGenes: numberOfMeetings.	g createGeneBlock: [ :rand :index :ind | (1 to: numberOfMeetings) atRandom: rand ].	g minimizeComparator.	g		fitnessBlock: [ :genes | 			| distribution |			distribution := OrderedCollection new.			numberOfMeetings timesRepeat: [ distribution add: OrderedCollection new ].			genes doWithIndex: [ :roomNumber :index | (distribution at: roomNumber) add: (meetings at: index) ].						numberOfOverlap := 0.			distribution do: [ :aSetOfMeetings |				table := OrderedCollection new: 10 withAll: 0.				aSetOfMeetings do: [ :meet |					meet first to: meet second do: [ :v | table at: v put: (table at: v) + 1 ]				].				numberOfOverlap := numberOfOverlap + (table select: [ :v | v &gt;= 2 ]) size.			].				(distribution select: #notEmpty) size + numberOfOverlap.			 ].	g run.	g result asSet size inspect.</body><body package="GeneticAlgorithm-Extensions" selector="example07">example07	"	self new example07	"	"The number of locate in the grid"	| list sums g |	list := #(2 4 6 8 10 12 14 16 18).		"The different combinations to sum.	E.g., the three first cells could be summed (#(1 2 3))		  the diagonal top-left to bottom-right (#1 5 9))"	sums := #( 		#(1 2 3)		#(4 5 6)		#(7 8 9)				#(1 5 9)		#(7 5 3)				#(1 4 7)		#(2 5 8)		#(3 6 9) ).	g := GAEngine new.	g populationSize: 400.	g endIfFitnessIsAbove: 9.	g mutationRate: 0.01.	g numberOfGenes: 9.	g createGeneBlock: [ :rand :index | list atRandom: rand. ].	g fitnessBlock: [ :genes |		| score penalty |		score := (sums collect: [ :arr |				(arr collect: [ :index | genes at: index]) sum ]) 					inject: 0 into: [ :a :b | a + (b - 30) abs ].		penalty := (genes size - genes asSet size) * 3.		9 - (score + penalty) ].	g run.	g inspect.</body></methods><methods><class-id>GeneticAlgorithm.GAMutationOperationTest</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Tests" selector="setUp">setUp	super setUp.	i := GAIndividual new genes: 'abcd' asArray.	op := GAMutationOperation new</body><body package="GeneticAlgorithm-Tests" selector="testMutation">testMutation	| i2 |	op random: (Random seed: 7).	op geneFactoryBlock: [ :r | ($a to: $z) atRandom: r ].	op mutationRate: 0.5.	i2 := op mutate: i.	self assert: i2 genes equals: 'xfcd' asArray.	i2 := op mutate: i2.	self assert: i2 genes equals: 'tfcd' asArray.	i2 := op mutate: i2.	self assert: i2 genes equals: 'tfjd' asArray</body><body package="GeneticAlgorithm-Tests" selector="testRandomAndGeneFactoryMustBeSet">testRandomAndGeneFactoryMustBeSet	self should: [ op mutate: i ] raise: Error.	op random: Random new.	self should: [ op mutate: i ] raise: Error.	op geneFactoryBlock: [ :r | 42 ].	self shouldnt: [ op mutate: i ] raise: Error</body></methods><methods><class-id>GeneticAlgorithm.GAMutationOperationTest class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Tests" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GAAbstractCrossoverOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="crossover:with:">crossover: partnerA with: partnerB	"Return a new child, which is the result of mixing myself with the argument"	^ self		crossover: partnerA		with: partnerB		midpoint: (self pickCutPointFor: partnerA)</body><body package="GeneticAlgorithm-Core" selector="crossover:with:midpoint:">crossover: partnerA with: partnerB midpoint: midpoint	"Return a new child, which is the result of mixing myself with the argument"	| child crossOverGenes |	child := GAIndividual new.	child random: random.	crossOverGenes := (partnerA genes first: midpoint)		, (partnerB genes allButFirst: midpoint).	child genes: crossOverGenes.	^ child</body><body package="GeneticAlgorithm-Core" selector="pickCutPointFor:">pickCutPointFor: anIndividual	"Need to be overridden in subclasses"	self subclassResponsibility</body></methods><methods><class-id>GeneticAlgorithm.GACrossoverOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="pickCutPointFor:">pickCutPointFor: partnerA	"Simply returns a random number between 1 and the number of genes of the individual provided as argument"	^ random nextInt: partnerA numberOfGenes</body></methods><methods><class-id>GeneticAlgorithm.GAConstrainedCrossoverOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="pickCutPointFor:">pickCutPointFor: partnerA	"Return a cutpoint"	self		assert: [ possibleCutpoints notNil ]		description: 'Need to provide the possible cut points, using #possibleCutpoints:'.	^ possibleCutpoints at: (random nextInt: possibleCutpoints size)</body><body package="GeneticAlgorithm-Core" selector="possibleCutpoints:">possibleCutpoints: indexes	"Set the possible pointcuts considered by the operator"	possibleCutpoints := indexes</body></methods><methods><class-id>GeneticAlgorithm.GAOrderedCrossoverOperation</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="crossover:with:">crossover: individualA with: individualB	"Return a new child, which is the result of mixing the two individuals"	| i1 i2 |	i1 := self pickCutPointFor: individualA.	i2 := self pickCutPointFor: individualA.	"Make sure that i1 is smaller than i2"	i1 &gt; i2		ifTrue: [ | t |			t := i1.			i1 := i2.			i2 := t ].	^ self		crossover: individualA		with: individualB		from: i1		to: i2</body><body package="GeneticAlgorithm-Core" selector="crossover:with:from:to:">crossover: individualA with: individualB from: i1 to: i2	"Return a new child, which is the result of mixing myself the two individuals. The method assumes that i1 &lt;= i2."	| child crossOverGenes runningIndex swath |	child := GAIndividual new.	child random: random.	swath := individualA genes copyFrom: i1 to: i2.	crossOverGenes := Array new: individualA genes size.	crossOverGenes := crossOverGenes		copyReplaceFrom: i1		to: i2		with: swath.	runningIndex := 1.	(individualB genes copyWithoutAll: swath)		do: [ :v | 			(crossOverGenes includes: v)				ifFalse: [ [ (crossOverGenes at: runningIndex) notNil ]						whileTrue: [ runningIndex := runningIndex + 1 ].					crossOverGenes at: runningIndex put: v ] ].	child genes: crossOverGenes.	^ child</body><body package="GeneticAlgorithm-Core" selector="pickCutPointFor:">pickCutPointFor: partner	"Simply return a random number between 1 and the number of genes of the individual provided as argument"	^ random nextInt: partner genes size</body></methods><methods><class-id>GeneticAlgorithm.GASelection</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="checkIfEngineSet">checkIfEngineSet	self assert: [ engine notNil ] description: 'Should set the engine'</body><body package="GeneticAlgorithm-Core" selector="checkIfInitialPopulationSet">checkIfInitialPopulationSet	self		assert: [ initialPopulation notNil ]		description: 'Should set the initial population'.	self		assert: [ initialPopulation isCollection ]		description: 'Has to be a collection'.	self		assert: [ initialPopulation notEmpty ]		description: 'Cannot be empty'</body><body package="GeneticAlgorithm-Core" selector="compareFitness:">compareFitness: aTwoArgBlock	"Take as argument a two-argument block that compares the fitness of two individuals"	compareFitness := aTwoArgBlock</body><body package="GeneticAlgorithm-Core" selector="createNewPopulation">createNewPopulation	"Create a new population"	self subclassResponsibility</body><body package="GeneticAlgorithm-Core" selector="crossover:with:">crossover: partnerA with: partnerB	"Return one child, result of the crossover over the two arguments"	^ engine crossover: partnerA with: partnerB</body><body package="GeneticAlgorithm-Core" selector="doSelection">doSelection	"Produce a new population using the selection algorithm"	self checkIfEngineSet.	self checkIfInitialPopulationSet.	populationSize := initialPopulation size.	fittest := initialPopulation first.	initialPopulation		do: [ :ind | 			ind computeFitnessUsing: fitnessBlock.			(self isIndividual: ind betterThan: fittest)				ifTrue: [ fittest := ind ] ].	self createNewPopulation.	initialPopulation := population</body><body package="GeneticAlgorithm-Core" selector="engine">engine	"Return the GAEngine to which the selection is associated to"	^ engine</body><body package="GeneticAlgorithm-Core" selector="engine:">engine: theEngine	"Set the GAEntine to which I have to be associated with"	engine := theEngine.	self checkIfEngineSet</body><body package="GeneticAlgorithm-Core" selector="fitnessBlock">fitnessBlock	"Return the one-arg block used to compute fitness of each individual"	^ fitnessBlock</body><body package="GeneticAlgorithm-Core" selector="fitnessBlock:">fitnessBlock: aOneArgBlock	"The argument is evaluated on the genes of each individual.	The block argument has to compute the fitness."	fitnessBlock := aOneArgBlock</body><body package="GeneticAlgorithm-Core" selector="fittest">fittest	"Return the fittest individual from the new population"	^ fittest</body><body package="GeneticAlgorithm-Core" selector="initialize">initialize	super initialize.	population := OrderedCollection new</body><body package="GeneticAlgorithm-Core" selector="initialPopulation:">initialPopulation: aPopulationAsIndividuals	"Set the initial population. This is used to create the new population"	initialPopulation := aPopulationAsIndividuals.	self checkIfInitialPopulationSet</body><body package="GeneticAlgorithm-Core" selector="isIndividual:betterThan:">isIndividual: ind betterThan: fittestIndividual	"Is the first individual better than the second?"	^ engine isIndividual: ind betterThan: fittestIndividual</body><body package="GeneticAlgorithm-Core" selector="mutate:">mutate: child	"Perform a mutation on the argument"	^ engine mutate: child</body><body package="GeneticAlgorithm-Core" selector="population">population	"Return the new population"	^ population</body><body package="GeneticAlgorithm-Core" selector="populationSize">populationSize	"Return the population size"	^ initialPopulation size</body><body package="GeneticAlgorithm-Core" selector="populationSize:">populationSize: anInteger	"Set the population size"	populationSize := anInteger</body><body package="GeneticAlgorithm-Core" selector="randomNumber:">randomNumber: value	"Return a number between 1 and value"	^ engine randomNumber: value</body></methods><methods><class-id>GeneticAlgorithm.GASelection class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Core" selector="new">new	^ super new initialize</body></methods><methods><class-id>GeneticAlgorithm.GATournamentSelection</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="createNewPopulation">createNewPopulation	"Return a new population made of newly breed individual"	| partnerA partnerB child |	population := (1 to: self populationSize)		collect: [ :seed | 			engine random: (Random seed: seed).			partnerA := self getGoodIndividual.			partnerB := self getGoodIndividual.			child := self mutate: (self crossover: partnerA with: partnerB).			child computeFitnessUsing: engine fitnessBlock.			child ]</body><body package="GeneticAlgorithm-Core" selector="getGoodIndividual">getGoodIndividual	"Return the best individual from tournamentSize individual randomly chosen from the population"	| best ind |	best := nil.	tournamentSize		timesRepeat: [ ind := initialPopulation				at: (self randomNumber: initialPopulation size).			(best isNil				or: [ compareFitness value: ind fitness value: best fitness ])				ifTrue: [ best := ind ] ].	^ best</body><body package="GeneticAlgorithm-Core" selector="initialize">initialize	super initialize.	tournamentSize := 5</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GeneticAlgorithm-Extensions" selector="anyOne">anyOne	^ self first</body><body package="GeneticAlgorithm-Extensions" selector="atRandom:">atRandom: aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	^ self at: (aGenerator nextInt: self size)</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="GeneticAlgorithm-Extensions" selector="with:collect:">with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'size' ].	result := self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="GeneticAlgorithm-Extensions" selector="cull:">cull: anArg	^ self numArgs = 0 		ifTrue: [self value]		ifFalse: [self value: anArg]	</body><body package="GeneticAlgorithm-Extensions" selector="cull:cull:">cull: firstArg cull: secondArg	^self numArgs &lt; 2 		ifTrue: [self cull: firstArg]		ifFalse: [self value: firstArg value: secondArg]	</body><body package="GeneticAlgorithm-Extensions" selector="cull:cull:cull:">cull: firstArg cull: secondArg cull: thirdArg	^self numArgs &lt; 3 		ifTrue: [self cull: firstArg cull: secondArg]		ifFalse: [self value: firstArg value: secondArg value: thirdArg]</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GeneticAlgorithm-Extensions" selector="average">average	^ self sum / self size</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="GeneticAlgorithm-Extensions" selector="copyWithoutAll:">copyWithoutAll: aCollection	"Answer a copy of the receiver that does not contain any elements 	equal to those in aCollection."	^ self reject: [:each | aCollection includes: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GeneticAlgorithm-Extensions" selector="isCollection">isCollection	^ true</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Extensions" selector="new:withAll:">new: aNumber withAll: anObject	| inst |	inst := self new: aNumber.	aNumber timesRepeat: [ inst add: anObject].	^ inst</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>initialize-release</category><body package="GeneticAlgorithm-Extensions" selector="initialize">initialize</body></methods><methods><class-id>Core.Object</class-id> <category>initialize-release</category><body package="GeneticAlgorithm-Extensions" selector="initialize">initialize</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GeneticAlgorithm-Extensions" selector="isCollection">isCollection	^ false</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="GeneticAlgorithm-Extensions" selector="to:">to: other	^ (self asInteger to: other asInteger) collect: [:val | Character value: val ]</body></methods><methods><class-id>Core.Random class</class-id> <category>instance creation</category><body package="GeneticAlgorithm-Extensions" selector="seed:">seed: aNumber	^ self new		seed: aNumber;		yourself</body></methods><methods><class-id>Core.Random</class-id> <category>accessing</category><body package="GeneticAlgorithm-Extensions" selector="nextInt:">nextInt: anInteger	anInteger &lt; 0 ifTrue: [ self error: 'no negative'].	^ (self next * anInteger) truncated + 1</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>evaluating</category><body package="GeneticAlgorithm-Extensions" selector="value:">value: anObject	^ anObject perform: self</body></methods><methods><class-id>GeneticAlgorithm.GAEngine</class-id> <category>as yet unclassified</category><body package="GeneticAlgorithm-Core" selector="gtInspectorLogsIn:">gtInspectorLogsIn: composite	&lt;gtInspectorPresentationOrder: -5&gt;	composite list		title: 'Logs';		display: [ self logs ]</body><body package="GeneticAlgorithm-Core" selector="gtInspectorViewIn:">gtInspectorViewIn: composite	&lt;gtInspectorPresentationOrder: -10&gt;	composite roassal2		title: 'View';		initializeView: [ self visualize ]</body></methods><methods><class-id>UIManager class</class-id> <category>interface specs</category><body package="GeneticAlgorithm-Extensions" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #specifiedPosition #openType #advanced #labelFromApplication false ) 			#label: 'Demo' 			#min: #(#{Core.Point} 300 30 ) 			#max: #(#{Core.Point} 300 30 ) 			#bounds: #(#{Graphics.Rectangle} 960 487 1260 517 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ProgressWidgetSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 -5 1 ) 					#name: #Percent 					#isOpaque: true 					#model: #percent 					#direction: #horizontal 					#position: #topLeft 					#area: true 					#reverse: false ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class></st-source>